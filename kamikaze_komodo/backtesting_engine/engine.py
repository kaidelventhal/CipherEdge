# kamikaze_komodo/backtesting_engine/engine.py
# Significantly updated to integrate PositionSizer and StopManager
# And to handle sentiment data (conceptual for now)
# Phase 5: BarData now has prediction_value, prediction_confidence. Engine will pass them along if present in data_feed_df
# or if strategy populates them on the BarData object.

import pandas as pd
from typing import List, Dict, Any, Optional, Tuple
from kamikaze_komodo.core.models import BarData, Trade, Order # Order not fully used
from kamikaze_komodo.core.enums import SignalType, OrderSide, TradeResult
from kamikaze_komodo.strategy_framework.base_strategy import BaseStrategy
from kamikaze_komodo.app_logger import get_logger
from datetime import datetime, timezone

# Phase 3 imports
from kamikaze_komodo.risk_control_module.position_sizer import BasePositionSizer, FixedFractionalPositionSizer # Default
from kamikaze_komodo.risk_control_module.stop_manager import BaseStopManager, PercentageStopManager # Default
from kamikaze_komodo.portfolio_constructor.asset_allocator import BaseAssetAllocator # For future use

logger = get_logger(__name__)

class BacktestingEngine:
    def __init__(
        self,
        data_feed_df: pd.DataFrame,
        strategy: BaseStrategy,
        initial_capital: float = 10000.0,
        commission_bps: float = 0.0, # e.g., 10 bps = 0.1%
        position_sizer: Optional[BasePositionSizer] = None,
        stop_manager: Optional[BaseStopManager] = None,
        # For Phase 4: sentiment data
        sentiment_data_df: Optional[pd.DataFrame] = None, # Timestamp-indexed series/df with sentiment scores
        # For Phase 5: ML prediction data (optional, can also be generated by strategy)
        # prediction_data_df: Optional[pd.DataFrame] = None # Timestamp-indexed with 'prediction_value', 'prediction_confidence'
    ):
        if data_feed_df.empty: raise ValueError("Data feed DataFrame cannot be empty.")
        if not isinstance(data_feed_df.index, pd.DatetimeIndex):
            raise ValueError("Data feed DataFrame must be indexed by pd.DatetimeIndex.")
        
        self.data_feed_df = data_feed_df.sort_index()
        self.strategy = strategy
        self.initial_capital = initial_capital
        self.commission_rate = commission_bps / 10000.0

        # Initialize Risk and Portfolio Components (Phase 3)
        self.position_sizer = position_sizer if position_sizer else FixedFractionalPositionSizer(fraction=0.1) # Default 10% equity allocation
        self.stop_manager = stop_manager if stop_manager else PercentageStopManager(stop_loss_pct=None, take_profit_pct=None) # Default no SL/TP from engine
        
        # Phase 4: Sentiment Data
        self.sentiment_data_df = sentiment_data_df # Expects 'timestamp' index and 'sentiment_score' column
        if self.sentiment_data_df is not None and not self.sentiment_data_df.empty:
            if not isinstance(self.sentiment_data_df.index, pd.DatetimeIndex):
                logger.warning("Sentiment data DataFrame must be indexed by pd.DatetimeIndex. Sentiment will not be used.")
                self.sentiment_data_df = None
            else: # Ensure timezone consistency (UTC)
                if self.sentiment_data_df.index.tz is None:
                    self.sentiment_data_df.index = self.sentiment_data_df.index.tz_localize('UTC')
                else:
                    self.sentiment_data_df.index = self.sentiment_data_df.index.tz_convert('UTC')
                logger.info(f"Sentiment data loaded with {len(self.sentiment_data_df)} entries.")

        # Phase 5: ML Prediction data could be passed here if pre-calculated.
        # For now, assuming ML strategies generate predictions internally or update BarData.
        # self.prediction_data_df = prediction_data_df 


        self.portfolio_history: List[Dict[str, Any]] = []
        self.trades_log: List[Trade] = []
        
        self.current_cash = initial_capital
        self.current_asset_value = 0.0 # Mark-to-market value of assets held
        self.current_portfolio_value = initial_capital # Total equity (cash + asset_value)
        
        self.active_trade: Optional[Trade] = None # Stores the currently open trade object
        self.trade_id_counter = 0

        logger.info(
            f"BacktestingEngine initialized for strategy '{strategy.name}' on symbol '{strategy.symbol}'. "
            f"Initial Capital: ${initial_capital:,.2f}, Commission: {commission_bps} bps."
        )
        logger.info(f"Position Sizer: {self.position_sizer.__class__.__name__}")
        logger.info(f"Stop Manager: {self.stop_manager.__class__.__name__}")
        if self.sentiment_data_df is not None and not self.sentiment_data_df.empty :
            logger.info("Sentiment data will be used in this backtest if strategy supports it.")


    def _get_next_trade_id(self) -> str:
        self.trade_id_counter += 1
        return f"trade_{self.trade_id_counter:05d}"

    def _update_portfolio_value(self, current_bar_close_price: Optional[float] = None):
        """Updates current_asset_value and current_portfolio_value."""
        if self.active_trade and current_bar_close_price is not None:
            self.current_asset_value = self.active_trade.amount * current_bar_close_price
        else:
            self.current_asset_value = 0.0
        self.current_portfolio_value = self.current_cash + self.current_asset_value


    def _execute_trade(
        self, 
        signal_type: SignalType, 
        timestamp: datetime, 
        price: float, # Execution price
        current_bar_for_atr_calc: Optional[BarData] = None # For ATR based sizer/stop
    ):
        commission_cost = 0.0
        trade_executed = False

        # --- POSITION ENTRY ---
        if signal_type == SignalType.LONG and self.active_trade is None:
            # Use PositionSizer
            atr_value_for_sizing = current_bar_for_atr_calc.atr if current_bar_for_atr_calc and hasattr(current_bar_for_atr_calc, 'atr') and current_bar_for_atr_calc.atr is not None else None
            
            position_size_units = self.position_sizer.calculate_size(
                symbol=self.strategy.symbol,
                current_price=price,
                available_capital=self.current_cash,
                current_portfolio_value=self.current_portfolio_value,
                latest_bar=current_bar_for_atr_calc, # Pass current bar for potential ATR calc by sizer
                atr_value=atr_value_for_sizing # Pass ATR if strategy calculated it
            )

            if position_size_units is None or position_size_units <= 1e-8: # Check for effectively zero size
                logger.debug(f"{timestamp} - Cannot enter LONG trade for {self.strategy.symbol}. PositionSizer returned no size or near-zero size ({position_size_units}).")
                return

            cost_of_assets = position_size_units * price
            commission_cost = cost_of_assets * self.commission_rate

            if cost_of_assets + commission_cost > self.current_cash:
                logger.warning(f"{timestamp} - Insufficient cash for LONG trade on {self.strategy.symbol}. Need {cost_of_assets + commission_cost:.2f}, have {self.current_cash:.2f}. Reducing size or skipping.")
                # Attempt to resize with available cash (simplified)
                # A more robust approach would be to cap `capital_to_allocate` in the sizer
                if price <= 0 or (1 + self.commission_rate) <= 0: # Avoid division by zero or negative price/rate
                    logger.error(f"{timestamp} - Price or commission rate is invalid for size adjustment. Skipping trade.")
                    return
                
                # Max units we can buy considering commission
                max_cost_before_commission = self.current_cash / (1 + self.commission_rate)
                adjusted_size_units = max_cost_before_commission / price
                
                if adjusted_size_units <= 1e-8 : # Effectively zero or negative
                    logger.warning(f"{timestamp} - Still insufficient cash after adjustment attempt, or adjusted size is too small. Skipping trade.")
                    return
                
                position_size_units = adjusted_size_units
                cost_of_assets = position_size_units * price
                commission_cost = cost_of_assets * self.commission_rate


            self.current_cash -= (cost_of_assets + commission_cost)
            
            # ATR at entry for ATRStopManager (if strategy provides it on BarData or calculates it)
            atr_at_entry = current_bar_for_atr_calc.atr if current_bar_for_atr_calc and current_bar_for_atr_calc.atr else None

            self.active_trade = Trade(
                id=self._get_next_trade_id(),
                symbol=self.strategy.symbol,
                entry_order_id=f"entry_{self.trade_id_counter}",
                side=OrderSide.BUY,
                entry_price=price,
                amount=position_size_units,
                entry_timestamp=timestamp,
                commission=commission_cost,
                custom_fields={"atr_at_entry": atr_at_entry} if atr_at_entry else {}
            )
            self._update_portfolio_value(price) # Update portfolio value with new asset holding
            logger.info(
                f"{timestamp} - EXECUTE LONG: {position_size_units:.6f} {self.strategy.symbol} @ ${price:.2f}. "
                f"Cost: ${cost_of_assets:.2f}, Comm: ${commission_cost:.2f}. Cash Left: ${self.current_cash:.2f}. Equity: ${self.current_portfolio_value:.2f}"
            )
            trade_executed = True

        # --- POSITION EXIT (e.g. from strategy signal) ---
        elif signal_type == SignalType.CLOSE_LONG and self.active_trade is not None and self.active_trade.side == OrderSide.BUY:
            exit_value = self.active_trade.amount * price
            commission_cost = exit_value * self.commission_rate

            self.current_cash += (exit_value - commission_cost)
            
            pnl_for_this_trade = (price - self.active_trade.entry_price) * self.active_trade.amount - self.active_trade.commission - commission_cost
            initial_trade_value = self.active_trade.entry_price * self.active_trade.amount
            pnl_percentage = (pnl_for_this_trade / initial_trade_value) * 100 if initial_trade_value != 0 else 0

            self.active_trade.exit_price = price
            self.active_trade.exit_timestamp = timestamp
            self.active_trade.pnl = pnl_for_this_trade
            self.active_trade.pnl_percentage = pnl_percentage
            self.active_trade.commission += commission_cost
            self.active_trade.result = TradeResult.WIN if pnl_for_this_trade > 0 else (TradeResult.LOSS if pnl_for_this_trade < 0 else TradeResult.BREAKEVEN)
            self.active_trade.exit_order_id = f"exit_{self.active_trade.id.split('_')[1]}"
            
            self.trades_log.append(self.active_trade.model_copy(deep=True)) # Log a copy
            
            logger.info(
                f"{timestamp} - EXECUTE CLOSE LONG (Signal): {self.active_trade.amount:.6f} {self.strategy.symbol} @ ${price:.2f}. "
                f"PnL: ${pnl_for_this_trade:.2f} ({pnl_percentage:.2f}%). Total Comm: ${self.active_trade.commission:.2f}. "
                f"Cash Now: ${self.current_cash:.2f}."
            )
            self.active_trade = None
            self._update_portfolio_value() # Assets back to 0
            trade_executed = True
        
        # Note: SHORT and CLOSE_SHORT signals are not handled here for simplicity
        elif signal_type in (SignalType.SHORT, SignalType.CLOSE_SHORT):
            logger.debug(f"{timestamp} - {signal_type.name} signals are not handled by this basic backtesting engine setup.")

        if trade_executed:
            self._update_portfolio_value(price if self.active_trade else None) # Recalculate equity


    def _handle_stop_take_profit(self, current_bar: BarData):
        """Checks and executes SL/TP using StopManager. Modifies self.active_trade and portfolio."""
        if self.active_trade is None or self.stop_manager is None:
            return

        # 1. Check Stop Loss
        stop_loss_trigger_price = self.stop_manager.check_stop_loss(self.active_trade, current_bar)
        if stop_loss_trigger_price is not None:
            logger.info(f"{current_bar.timestamp} - STOP LOSS triggered for trade {self.active_trade.id} at derived price {stop_loss_trigger_price:.2f}")
            # Simulate exit at the stop_loss_trigger_price (or bar.low/high depending on side and realism)
            # For simplicity, assume it's hit at the trigger_price itself.
            self._execute_exit(current_bar.timestamp, stop_loss_trigger_price, "StopLoss")
            return # Exit, don't check for TP if SL hit

        # 2. Check Take Profit (only if SL not triggered)
        if self.active_trade: # SL might have closed the trade
            take_profit_trigger_price = self.stop_manager.check_take_profit(self.active_trade, current_bar)
            if take_profit_trigger_price is not None:
                logger.info(f"{current_bar.timestamp} - TAKE PROFIT triggered for trade {self.active_trade.id} at derived price {take_profit_trigger_price:.2f}")
                self._execute_exit(current_bar.timestamp, take_profit_trigger_price, "TakeProfit")
                return

    def _execute_exit(self, timestamp: datetime, price: float, exit_reason: str):
        """ Helper to execute an exit for an active trade (SL, TP, or EOD). """
        if not self.active_trade: return

        exit_value = self.active_trade.amount * price
        commission_cost = exit_value * self.commission_rate
        self.current_cash += (exit_value - commission_cost)

        pnl_for_this_trade = (price - self.active_trade.entry_price) * self.active_trade.amount - self.active_trade.commission - commission_cost
        initial_trade_value = self.active_trade.entry_price * self.active_trade.amount
        pnl_percentage = (pnl_for_this_trade / initial_trade_value) * 100 if initial_trade_value != 0 else 0
        
        self.active_trade.exit_price = price
        self.active_trade.exit_timestamp = timestamp
        self.active_trade.pnl = pnl_for_this_trade
        self.active_trade.pnl_percentage = pnl_percentage
        self.active_trade.commission += commission_cost
        self.active_trade.result = TradeResult.WIN if pnl_for_this_trade > 0 else (TradeResult.LOSS if pnl_for_this_trade < 0 else TradeResult.BREAKEVEN)
        self.active_trade.notes = exit_reason
        self.active_trade.exit_order_id = f"{exit_reason.lower()}_{self.active_trade.id.split('_')[1]}"

        self.trades_log.append(self.active_trade.model_copy(deep=True))
        
        logger.info(
            f"{timestamp} - EXECUTE CLOSE LONG ({exit_reason}): {self.active_trade.amount:.6f} {self.strategy.symbol} @ ${price:.2f}. "
            f"PnL: ${pnl_for_this_trade:.2f} ({pnl_percentage:.2f}%). Total Comm: ${self.active_trade.commission:.2f}. "
            f"Cash Now: ${self.current_cash:.2f}."
        )
        self.active_trade = None
        self._update_portfolio_value() # Recalculate equity (assets become 0)


    def run(self) -> tuple[List[Trade], Dict[str, Any]]:
        logger.info(f"Starting backtest run for strategy '{self.strategy.name}'...")
        # Reset strategy's internal data history if it maintains one beyond what's passed in BarData
        self.strategy.data_history = pd.DataFrame(columns=[
            'open', 'high', 'low', 'close', 'volume', 'atr', 
            'sentiment_score', 'prediction_value', 'prediction_confidence'
        ])


        for timestamp, row in self.data_feed_df.iterrows():
            ts_aware = timestamp.tz_localize('UTC') if timestamp.tzinfo is None else timestamp.tz_convert('UTC')
            
            # Prepare BarData object, including potential pre-calculated ML predictions from data_feed_df
            bar_data_args = {
                "timestamp": ts_aware, "open": row['open'], "high": row['high'],
                "low": row['low'], "close": row['close'], "volume": row['volume'],
                "symbol": self.strategy.symbol, "timeframe": self.strategy.timeframe,
                "atr": row.get('atr'), # If ATR is pre-calculated on data_feed_df
                "prediction_value": row.get('prediction_value'), # Phase 5
                "prediction_confidence": row.get('prediction_confidence') # Phase 5
            }
            
            # Phase 4: Incorporate external sentiment data if available
            current_sentiment_score = None
            if self.sentiment_data_df is not None and not self.sentiment_data_df.empty:
                try:
                    if not self.sentiment_data_df.index.is_monotonic_increasing:
                        self.sentiment_data_df = self.sentiment_data_df.sort_index()
                    
                    sentiment_value = self.sentiment_data_df['sentiment_score'].asof(ts_aware)
                    if pd.notna(sentiment_value):
                        current_sentiment_score = sentiment_value
                        bar_data_args["sentiment_score"] = current_sentiment_score # Add to BarData
                except KeyError:
                    pass 
                except Exception as e_sentiment:
                    logger.warning(f"Error accessing sentiment data for {ts_aware}: {e_sentiment}")

            current_bar = BarData(**bar_data_args)
            
            # 1. Check SL/TP first based on H/L prices of current bar
            if self.active_trade:
                self._handle_stop_take_profit(current_bar)
            
            # 2. If no SL/TP triggered (or no active trade), get signal from strategy
            if self.active_trade is None or not (self.active_trade.exit_price is not None): # If trade still open or no trade
                # Strategy's on_bar_data might update current_bar with its own calculated ATR or predictions
                signal = self.strategy.on_bar_data(current_bar, sentiment_score=current_sentiment_score) 
                
                if signal and signal != SignalType.HOLD:
                    execution_price = current_bar.close # Assume execution at close of signal bar
                    # Pass current_bar which might now have ATR/predictions from strategy
                    self._execute_trade(signal, current_bar.timestamp, execution_price, current_bar_for_atr_calc=current_bar)

            # 3. Log portfolio state at the end of each bar
            self._update_portfolio_value(current_bar.close) # Update with current bar's close for MTM
            self.portfolio_history.append({
                "timestamp": current_bar.timestamp,
                "cash": self.current_cash,
                "asset_value": self.current_asset_value,
                "total_value": self.current_portfolio_value, # This is equity
                "current_price": current_bar.close,
                "active_trade_pnl": (self.current_portfolio_value - self.active_trade.entry_price * self.active_trade.amount - self.active_trade.commission) if self.active_trade else 0.0
            })

        # End of backtest: close any open position
        if self.active_trade:
            last_bar_data_row = self.data_feed_df.iloc[-1]
            last_bar_timestamp = self.data_feed_df.index[-1].tz_localize('UTC') if self.data_feed_df.index[-1].tzinfo is None else self.data_feed_df.index[-1].tz_convert('UTC')
            last_bar_close = last_bar_data_row['close']
            logger.info(f"{last_bar_timestamp} - End of backtest. Closing open {self.active_trade.side.value} position for {self.strategy.symbol} at ${last_bar_close:.2f}")
            self._execute_exit(last_bar_timestamp, last_bar_close, "EndOfBacktest")
        
        self._update_portfolio_value() # Final update (asset value should be 0)
        final_portfolio_state = {
            "initial_capital": self.initial_capital,
            "final_portfolio_value": self.current_portfolio_value, # Should be mostly cash
            "final_cash": self.current_cash,
            "end_timestamp": self.data_feed_df.index[-1]
        }
        
        logger.info(f"Backtest run completed. Final Portfolio Value: ${final_portfolio_state['final_portfolio_value']:.2f}")
        return self.trades_log, final_portfolio_state